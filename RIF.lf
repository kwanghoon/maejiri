;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; The Formal Definition of RIF in LF
;;     (RIF: Refined Imperative Fixped-Point Calculus)
;;
;; By Kwanghoon Choi
;;
;; Ref. Borgstrom, Gordon, Pucella, Roles, Stacks, Histories: 
;;      A Triple for Hoare, JFP, 2010.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

@type

 ;; Syntactic Categories

 Val  : Type.  ;; Value
 Prop : Type.  ;; Proposition

 H : Type.     ;; h

 ;; Judgment

 T : Prop -> Type.

@term

 ;; First-order Formula C
 ;; Operations

 equal  : Val  -> Val   -> Prop.
 not    : Prop -> Prop.
 imply  : Prop -> Prop  -> Prop.
 exists : (Val -> Prop) -> Prop.
 forall : (Val -> Prop) -> Prop.
 conj   : Prop -> Prop  -> Prop.
 disj   : Prop -> Prop  -> Prop. 

 ;; Axioms and Rules

 eq0 : /\x:Val. T (equal x x).
 eq1 : /\x:Val./\y:Val./\t:Val->Val. T (equal x y) -> T (equal (t x) (t y)).
 eq2 : /\x:Val./\y:Val./\f:Val->Prop. T (equal x y) -> T (f x) -> T (f y).

 not_i : /\phi:Prop./\psi:Prop. (T phi -> T psi) -> (T phi -> T (not psi)) 
              -> T (not phi).

 conj_i : /\phi:Prop./\psi:Prop.T phi -> T psi -> T (conj phi psi).

 disj_i_left  : /\phi:Prop./\psi:Prop. T phi -> T (disj phi psi).
 disj_i_right : /\phi:Prop./\psi:Prop. T psi -> T (disj phi psi).

 conj_e_left  : /\phi:Prop./\psi:Prop. T (conj phi psi) -> T phi.
 conj_e_right : /\phi:Prop./\psi:Prop. T (conj phi psi) -> T psi.

 notnot : /\phi:Prop. T (not (not phi)) -> T phi.

 disj_e : /\phi:Prop./\psi:Prop./\nu:Prop. (T phi -> T nu) -> (T psi -> T nu) 
              -> (T (disj phi psi) -> T nu).

 imply_e : /\phi:Prop./\psi:Prop. (T (imply phi psi)) -> T phi -> T psi.
 imply_i : /\phi:Prop./\psi:Prop. (T phi -> T psi) -> T (imply phi psi).

 exists_e : /\f:Val->Prop./\phi:Prop. T (exists f) 
              -> (/\x:Val. T (f x) -> T phi) -> T phi.
 exists_i : /\f:Val->Prop./\t:Val. T (f t) -> T (exists f).
 forall_e : /\f:Val->Prop./\t:Val. T (forall f) -> f t.
 forall_i : /\f:Val->Prop. (/\t:Val. T (f t)) -> T (forall f).

 ;; Value Constructor

 inl  : H.     ;; h ::= inl
 inr  : H.     ;;    |  inr
 fold : H.     ;;    |  fold

 ;; Value
                                              ;; M,N ::= x
 unit  : Val                                  ;;      |  ()
 fun   : (Val -> Exp) -> Val                  ;;      |  fun x.A
 pair  : Val -> Val -> Val                    ;;      |  (M,N)
 const : H -> Val -> Val                      ;;      |  h M

 ;; Expression

 lift  : Val -> Exp                              ;; A,B ::= M
 app   : Val -> Val -> Exp                       ;;      |  M N
 eqexp : Val -> Val -> Exp                       ;;      |  M = N
 let   : Exp -> (Val -> Exp) -> Exp              ;;      |  let x = A in B
 split : Val -> (Val -> Val -> Exp) -> Exp       ;;      |  let (x,y) = M in B
 match : Val -> (H -> Val -> Exp) -> Exp -> Exp  ;;      |  match M with 
                                                 ;;          h x -> A
                                                 ;;          else   B

@def

 ; p1 : o
 p1 = imply (forall (\x:Val. equal x x)) (exists (\x:Val. equal x x)).
